---
layout: post
title: Solving the Countdown Numbers Problem with F#
image: 'placeholder.png'
tags:
- combinatorics
- countdown
- f#
- permutation
- Programming
status: publish
type: post
published: true
meta: {}
---
<p>Countdown Problem is a game from the UK TV described in the following <a href="http://www.cs.nott.ac.uk/~gmh/countdown.pdf">link</a> (PDF).&#160; Basically, giving a set of numbers&#160; and a single number, you have to use the arithmetic&#160; operation to build a expression of the given numbers (in any subset and order) , that evaluate to the specified number.&#160;&#160; I will call this task in this article “The Countdown Problem”, since using the word “Problem” makes it sounds more as an academic (or as a homework , see the first comment on my <a href="http://stackoverflow.com/questions/1563271/3d-bin-packing-algorithm">question</a> on Stackoverflow).</p>  <p>&#160;</p>  <p>I came across this Problem after watching the &quot;Functional Programming Fundamentals” <a href="http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/">series</a> on Channel9, with Erik Mejer. <a href="http://www.cs.nott.ac.uk/~gmh/">Graham Hutton</a> (the author of <a href="http://www.cs.nott.ac.uk/~gmh/book.html">Programming in Haskell</a>) guest-hosted the 11th episode and showed how to solve this problem using brute force with Haskell. As I’m learning F# currently I started to implement the program in F# as well. Despite being heavily based on the Haskell solution from that episode, this code is not an accurate translation of the Haskell code. It just uses the same ideas.</p>  <p>&#160;</p>  <p>At first let us make a structure to hold the possible operations:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:8134d21b-f087-411f-a68a-f8475133ca75" class="wlWriterEditableSmartContent"><div style="font-family:consolas,lucida console,courier,monospace">
<span style="color:#008000"><b>type</b></span>&#160;<span style="color:#0000FF"><b>Op</b></span>&#160;<span style="color:#666666">=</span>&#160;<span style="color:#0000FF"><b>Add</b></span>&#160;<span style="color:#666666">|</span>&#160;<span style="color:#0000FF"><b>Sub</b></span>&#160;<span style="color:#666666">|</span>&#160;<span style="color:#0000FF"><b>Mul</b></span>&#160;<span style="color:#666666">|</span>&#160;<span style="color:#0000FF"><b>Div</b></span><br />
</div>
</div>  <p>This kind of types is called <a href="http://msdn.microsoft.com/en-us/library/dd233226(VS.100).aspx">discriminated unions</a> which means that an instance of this type is one of the named cases. An operation could be any of the following cases: Addition, Subtraction, multiplication or division.</p>  <p>The second type is an arithmetic expression, which may either be an integer or two expressions combined using an operation from the previous ones:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:fd51dbeb-f806-48d1-b9bc-ae122239b7d0" class="wlWriterEditableSmartContent"><div style="font-family:consolas,lucida console,courier,monospace">
<span style="color:#008000"><b>type</b></span>&#160;<span style="color:#0000FF"><b>Expr</b></span>&#160;<span style="color:#666666">=</span>&#160;<span style="color:#0000FF"><b>Val</b></span>&#160;<span style="color:#008000"><b>of</b></span>&#160;<span style="color:#B00040">int</span>&#160;<br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#666666">|</span>&#160;&#160;<span style="color:#0000FF"><b>App</b></span>&#160;<span style="color:#008000"><b>of</b></span>&#160;<span style="color:#0000FF"><b>Op</b></span>&#160;<span style="color:#666666">*</span>&#160;<span style="color:#0000FF"><b>Expr</b></span>&#160;<span style="color:#666666">*</span>&#160;<span style="color:#0000FF"><b>Expr</b></span><br />
</div>
</div>  <p>Boy, I love discriminated unions ;)</p>  <p>&#160;</p>  <p>Now we have the structures to hold the possible combinations, we still have to generate then in some way. For a set of numbers&#160; we have to generate all possible subsets, and for each of those subsets all permutations have to be generated. Its obvious that this task can be composed from two separate functions: building subsets and permutating them.</p>  <p>The first function generate all subsets of the set of numbers:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:d78262cc-7d71-4adc-8e55-2355970c4962" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span>&#160;<span style="color: #008000"><b>rec</b></span> subSets items <span style="color: #666666">=</span>       <p>&#160;&#160;&#160; <span style="color: #008000"><b>match</b></span> items <span style="color: #008000"><b>with</b></span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span>&#160;<span style="color: #008000">[]</span>&#160;<span style="color: #666666">-&gt;</span> seq<span style="color: #666666">{</span>yield <span style="color: #008000">[]</span><span style="color: #666666">}</span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span> x<span style="color: #666666">::</span>xs <span style="color: #666666">-&gt;</span> seq<span style="color: #666666">{</span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>let</b></span> sub <span style="color: #666666">=</span> subSets xs</p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield<span style="color: #666666">!</span> sub</p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield<span style="color: #666666">!</span> sub <span style="color: #666666">|&gt;</span>&#160;<span style="color: #0000ff"><b>Seq</b></span>.map <span style="color: #666666">(</span><span style="color: #008000"><b>fun</b></span> l <span style="color: #666666">-&gt;</span> x<span style="color: #666666">::</span>l<span style="color: #666666">)</span>&#160;<span style="color: #666666">}</span></p>   </div> </div>  <p>This exploits the simple idea that for each element of the set there are two almost identical categories of subsets;&#160; subsets that include this element, and the matching subsets that don’t. This could be exploited using an inductive approach to generate the subsets of small sets and then adding new elements successively to those sets.&#160; This function returns a sequence instead of an instance of Set because the number of subsets is exponential to the number of elements in the original set.&#160; Sequences are lazy evaluated, and thus consume less memory. There are 2<sup>n</sup> subsets of any set of n elements.</p>  <p>The Second function generates for a giving set&#160; alls possible permutations:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:dddd41bf-874d-4005-81c7-f6f8b0027f7d" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span>&#160;<span style="color: #008000"><b>rec</b></span> permutations items <span style="color: #666666">=</span>       <p>&#160;&#160;&#160; <span style="color: #008000"><b>match</b></span> items <span style="color: #008000"><b>with</b></span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span>&#160;<span style="color: #008000">[]</span>&#160;<span style="color: #666666">-&gt;</span> seq<span style="color: #666666">{</span>yield <span style="color: #008000">[]</span><span style="color: #666666">}</span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span>&#160;<span style="color: #666666">_</span>&#160;<span style="color: #666666">-&gt;</span>&#160; seq<span style="color: #666666">{</span><span style="color: #008000"><b>for</b></span> x <span style="color: #008000"><b>in</b></span> items <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>let</b></span> oth <span style="color: #666666">=</span>&#160;<span style="color: #666666">[</span><span style="color: #008000"><b>for</b></span> c <span style="color: #008000"><b>in</b></span> items <span style="color: #008000"><b>do</b></span>&#160;<span style="color: #008000"><b>if</b></span> c <span style="color: #666666">&lt;&gt;</span> x <span style="color: #008000"><b>then</b></span> yield c <span style="color: #666666">]</span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield<span style="color: #666666">!</span> permutations oth <span style="color: #666666">|&gt;</span>&#160;<span style="color: #0000ff"><b>Seq</b></span>.map <span style="color: #666666">(</span><span style="color: #008000"><b>fun</b></span> l <span style="color: #666666">-&gt;</span> x<span style="color: #666666">::</span>l<span style="color: #666666">)</span>&#160;<span style="color: #666666">}</span></p>   </div> </div>  <p>This function returns n! different permutations for each set of n elements.</p>  <p>Now we can compose both methods to retrieve a method that generates all permutations of all subsets of a given set:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:f0580702-8ba5-460d-8379-64f917f81eda" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span> choices items <span style="color: #666666">=</span>&#160; <p>&#160;&#160;&#160; seq<span style="color: #666666">{</span><span style="color: #008000"><b>for</b></span> x <span style="color: #008000"><b>in</b></span> subSets items <span style="color: #008000"><b>do</b></span>&#160;&#160;&#160; </p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield<span style="color: #666666">!</span> permutations x <span style="color: #666666">}</span></p>   </div> </div>  <p>Given a set of n elements, this function returns n!.2<sup>n</sup> different choices, which is a huge number. For n=6 choices yields&#160; 46080&#160; elements.</p>  <p>After building all possible permutated subsets of the number set there is still many ways to combine them into an arithmetic expression.&#160; An arithmetic could be represented as a binary tree. Each node in this tree is an operation and the leaves are numbers. Building a binary tree could be done by splitting combining both binary trees into one with a single root node. This could be repeated recursively for all possible sub trees and possible splitting points to generate all binary trees:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:6160ad60-4275-456d-8259-5b6e79adf241" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span>&#160;<span style="color: #008000"><b>rec</b></span> generateExpressions nums <span style="color: #666666">=</span>       <p>&#160;&#160;&#160; <span style="color: #008000"><b>match</b></span> nums <span style="color: #008000"><b>with</b></span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #008000">[]</span>&#160;<span style="color: #666666">-&gt;</span>&#160;<span style="color: #0000ff"><b>Seq</b></span>.empty</p>      <p>&#160;&#160;&#160; <span style="color: #666666">|[</span>a<span style="color: #666666">]</span>&#160;<span style="color: #666666">-&gt;</span> seq<span style="color: #666666">{</span>yield <span style="color: #0000ff"><b>Val</b></span><span style="color: #666666">(</span>a<span style="color: #666666">)}</span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|_-&gt;</span>seq<span style="color: #666666">{</span><span style="color: #008000"><b>for</b></span> posnum <span style="color: #008000"><b>in</b></span> choices nums <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>for</b></span>&#160;<span style="color: #666666">(</span>f<span style="color: #666666">,</span>s<span style="color: #666666">)</span>&#160;<span style="color: #008000"><b>in</b></span> split posnum <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>for</b></span> first <span style="color: #008000"><b>in</b></span> generateExpressions f <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>for</b></span> second <span style="color: #008000"><b>in</b></span> generateExpressions s <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>for</b></span> op <span style="color: #008000"><b>in</b></span>&#160;<span style="color: #666666">[</span><span style="color: #0000ff"><b>Add</b></span><span style="color: #666666">;</span><span style="color: #0000ff"><b>Sub</b></span><span style="color: #666666">;</span><span style="color: #0000ff"><b>Mul</b></span><span style="color: #666666">;</span><span style="color: #0000ff"><b>Div</b></span><span style="color: #666666">]</span>&#160;<span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield <span style="color: #0000ff"><b>App</b></span><span style="color: #666666">(</span>op<span style="color: #666666">,</span>first<span style="color: #666666">,</span>second<span style="color: #666666">)}</span></p>   </div> </div>  <p>This yields an enormous number of binary trees. For a fixed number of leaves n one could construct (2n)! /((n+a)!n!) different trees.&#160;&#160; We will see in a coming article how to reduce this number by avoiding redundant expressions because of the commutatively of adding and multiplication.&#160;&#160; “split” is the function that splits a list into two non trivial list without changing the order of elements.</p>  <p>&#160;</p>  <p>Now we move to the evaluating arithmetical expressions.&#160; The function “eval” takes an expression and returns an list of integers. This is a common technique when programming in Haskell to express Null. If the expression is valid the function will evaluate it and return a singleton listing containing the result otherwise it will return an empty list.</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:3cf8654f-cc70-4b80-9145-95be8e71b910" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span>&#160;<span style="color: #008000"><b>rec</b></span> eval expr <span style="color: #666666">=</span>       <p>&#160;&#160;&#160; <span style="color: #008000"><b>match</b></span> expr <span style="color: #008000"><b>with</b></span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #0000ff"><b>Val</b></span><span style="color: #666666">(</span>n<span style="color: #666666">)</span>&#160;<span style="color: #666666">-&gt;</span>&#160;<span style="color: #666666">[</span>n<span style="color: #666666">]</span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #0000ff"><b>App</b></span><span style="color: #666666">(</span>op<span style="color: #666666">,</span> left<span style="color: #666666">,</span> right<span style="color: #666666">)</span>&#160; <span style="color: #666666">-&gt;</span>&#160;</p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #666666">[</span><span style="color: #008000"><b>for</b></span> l <span style="color: #008000"><b>in</b></span> eval left <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>for</b></span> r <span style="color: #008000"><b>in</b></span> eval right <span style="color: #008000"><b>do</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>if</b></span> valid op l r <span style="color: #008000"><b>then</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield apply op l r<span style="color: #666666">]</span></p>   </div> </div>  <p>“valid” is a simple function that ensure that all intermediate results are natural numbers. If valid of sum expression returned false all tree containing the sub tree of this expression are invalid.:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:c721418c-3404-461c-8ff7-d125f99766c6" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span> valid op f s&#160; <span style="color: #666666">=</span>&#160; <p>&#160;&#160;&#160; <span style="color: #008000"><b>match</b></span> op <span style="color: #008000"><b>with</b></span></p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #0000ff"><b>Add</b></span>&#160;<span style="color: #666666">-&gt;</span>&#160;<span style="color: #008000">true</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; </p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #0000ff"><b>Sub</b></span>&#160;<span style="color: #666666">-&gt;</span> f <span style="color: #666666">&gt;=</span> s</p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #0000ff"><b>Mul</b></span>&#160;<span style="color: #666666">-&gt;</span>&#160;<span style="color: #008000">true</span>&#160;&#160; </p>      <p>&#160;&#160;&#160; <span style="color: #666666">|</span><span style="color: #0000ff"><b>Div</b></span>&#160;<span style="color: #666666">-&gt;</span>&#160;<span style="color: #666666">(</span>s <span style="color: #666666">&lt;&gt;</span>&#160;<span style="color: #666666">0</span><span style="color: #666666">)</span>&#160;<span style="color: #666666">&amp;&amp;</span>&#160;<span style="color: #666666">(</span>f <span style="color: #666666">%</span> s <span style="color: #666666">=</span>&#160;<span style="color: #666666">0</span><span style="color: #666666">)</span>&#160;&#160; </p>   </div> </div>  <p>Now we have all necessary tools to iterate thru all possible combinations and returning the&#160; ones which matching result:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:875c5af6-fb12-4320-aadf-b1c21562e7eb" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br /><span style="color: #008000"><b>let</b></span> solutions nums result <span style="color: #666666">=</span>       <p>&#160;&#160;&#160; seq <span style="color: #666666">{</span><span style="color: #008000"><b>for</b></span> ex <span style="color: #008000"><b>in</b></span> generateExpressions nums <span style="color: #008000"><b>do</b></span>&#160;</p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000"><b>if</b></span>&#160;<span style="color: #666666">(</span>eval ex <span style="color: #666666">|&gt;</span>&#160;<span style="color: #0000ff"><b>Seq</b></span>.to_list<span style="color: #666666">)</span>&#160;<span style="color: #666666">=</span>&#160;<span style="color: #666666">[</span>result<span style="color: #666666">]</span>&#160;<span style="color: #008000"><b>then</b></span></p>      <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield ex<span style="color: #666666">}</span></p>   </div> </div>  <p>&#160;</p>  <p>Running this function on the same input as the one presented in the Haskell lecture of Hutton returns the same result:</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:2EC9848E-067D-4e79-BAB7-06CA927DB962:75b8ba41-0232-4aa2-a175-b09cebf252ae" class="wlWriterSmartContent">   <div style="font-family: consolas,lucida console,courier,monospace">     <br />solutions <span style="color: #666666">[</span><span style="color: #666666">1</span><span style="color: #666666">;</span>&#160;<span style="color: #666666">3</span><span style="color: #666666">;</span>&#160;<span style="color: #666666">7</span><span style="color: #666666">;</span>&#160;<span style="color: #666666">10</span><span style="color: #666666">;</span>&#160;<span style="color: #666666">25</span><span style="color: #666666">;</span>&#160;<span style="color: #666666">50</span><span style="color: #666666">]</span>&#160;<span style="color: #666666">765</span>&#160;&#160;&#160; <p>&#160;&#160;&#160; <span style="color: #666666">|&gt;</span>&#160;<span style="color: #0000ff"><b>Seq</b></span>.length</p>   </div> </div>  <p>The only problem with this Algorithm is the runtime. It takes too much to calculate the result.</p>  <p>Finding one solution is relative fast, but finding all results takes for ever. In the coming article I will try to reduce the runtime by avoiding redundant arithmetic expressions.</p>  <p>The code exists on <a href="http://github.com/mouk/Countdown">http://github.com/mouk/Countdown</a> and will be updated to reflect the planed changes.</p>
